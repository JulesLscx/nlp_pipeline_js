<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Browser-Based Text Analysis Tool</title>
    <style>
        :root {
            --primary-color: #3498db;
            --secondary-color: #2c3e50;
            --light-bg: #f8f9fa;
            --border-color: #dee2e6;
            --success-color: #28a745;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f0f2f5;
            color: #333;
            line-height: 1.6;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
            background: white;
            padding: 40px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        h1 {
            text-align: center;
            color: var(--secondary-color);
            margin-bottom: 30px;
        }

        .step {
            margin-bottom: 30px;
            padding: 20px;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            background: #fff;
            opacity: 0.5;
            pointer-events: none;
            transition: opacity 0.3s;
        }

        .step.active {
            opacity: 1;
            pointer-events: auto;
            border-left: 5px solid var(--primary-color);
        }

        .step h2 {
            margin-top: 0;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 10px;
            color: var(--secondary-color);
        }

        .form-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
        }

        input[type="text"],
        input[type="number"],
        select,
        textarea {
            width: 100%;
            padding: 10px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            box-sizing: border-box;
            font-size: 14px;
        }

        button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.3s;
        }

        button:hover {
            background-color: #2980b9;
        }

        button.secondary {
            background-color: #95a5a6;
        }

        button.secondary:hover {
            background-color: #7f8c8d;
        }

        button.remove-btn {
            background-color: #e74c3c;
            padding: 5px 10px;
            margin-left: 10px;
        }

        button.remove-btn:hover {
            background-color: #c0392b;
        }

        /* Pipeline Styles */
        #pipeline-container {
            border: 1px dashed var(--border-color);
            padding: 15px;
            min-height: 50px;
            background: var(--light-bg);
            margin-bottom: 15px;
        }

        .pipeline-item {
            background: white;
            border: 1px solid var(--border-color);
            padding: 10px;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-radius: 4px;
        }

        .pipeline-item .controls {
            display: flex;
            align-items: center;
        }

        .pipeline-item .details {
            flex-grow: 1;
            margin-right: 10px;
        }

        #cleaning-preview-container {
            margin-top: 15px;
            border: 1px solid var(--border-color);
            padding: 10px;
            display: none;
            background: var(--light-bg);
        }

        /* Results Styles */
        #results-area {
            display: none;
        }

        .results-section {
            margin-top: 30px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 14px;
        }

        th, td {
            border: 1px solid var(--border-color);
            padding: 8px;
            text-align: left;
        }

        th {
            background-color: var(--light-bg);
        }

        .scrollable-table {
            max-height: 400px;
            overflow-y: auto;
            border: 1px solid var(--border-color);
        }

        canvas {
            border: 1px solid var(--border-color);
            background: white;
            cursor: crosshair;
        }

        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px;
            border-radius: 4px;
            pointer-events: none;
            font-size: 12px;
            max-width: 300px;
            z-index: 100;
            display: none;
        }
    </style>
</head>
<body>

<div class="container">
    <h1>Text Analysis Tool</h1>

    <!-- Step 1: Data Input -->
    <div id="step-1" class="step active">
        <h2>1. Data Input</h2>

        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 10px;">
            <div class="form-group">
                <label>Delimiter</label>
                <select id="csv-delimiter">
                    <option value=",">Comma (,)</option>
                    <option value=";">Semicolon (;)</option>
                    <option value="	">Tab (\t)</option>
                </select>
            </div>
            <div class="form-group">
                <label>Encoding</label>
                <select id="csv-encoding">
                    <option value="UTF-8">UTF-8</option>
                    <option value="ISO-8859-1">ISO-8859-1 (Latin1)</option>
                </select>
            </div>
        </div>

        <div class="form-group">
            <label for="csv-file">Upload CSV File</label>
            <input type="file" id="csv-file" accept=".csv">
        </div>
        <div class="form-group" id="column-select-group" style="display:none;">
            <label for="target-column">Select Text Column</label>
            <select id="target-column"></select>
            <button id="confirm-column-btn" style="margin-top: 10px;">Confirm Selection</button>
        </div>
    </div>

    <!-- Step 2: Text Cleaning Pipeline -->
    <div id="step-2" class="step">
        <h2>2. Text Cleaning Pipeline</h2>
        <div id="pipeline-container">
            <p id="pipeline-empty-msg" style="color: #999; text-align: center;">No operations added.</p>
        </div>

        <div class="form-group" style="display: flex; gap: 10px;">
            <select id="operation-select">
                <option value="lowercase">To Lowercase</option>
                <option value="punctuation">Remove Punctuation</option>
                <option value="french_stopwords">Remove French Stop Words</option>
                <option value="regex_remove">Remove Lines by Regex</option>
                <option value="custom">Custom Function Block</option>
            </select>
            <button id="add-op-btn">+</button>
        </div>

        <div style="margin-top: 10px; margin-bottom: 10px;">
            <button id="preview-cleaning-btn" class="secondary">Preview Cleaning</button>
        </div>

        <div id="cleaning-preview-container"></div>

        <button id="confirm-pipeline-btn" style="margin-top: 15px;">Next: Configure Analysis</button>
    </div>

    <!-- Step 3: Analysis Configuration -->
    <div id="step-3" class="step">
        <h2>3. Analysis Configuration</h2>

        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
            <div>
                <h3>TF-IDF Vectorizer</h3>
                <div class="form-group">
                    <label>Min Document Frequency (min_df)</label>
                    <input type="number" id="min-df" value="1" min="1">
                </div>
                <div class="form-group">
                    <label>Max Document Frequency (max_df, 0.0 - 1.0)</label>
                    <input type="number" id="max-df" value="1.0" step="0.05" min="0" max="1">
                </div>
                <div class="form-group">
                    <label>N-Gram Range</label>
                    <div style="display: flex; gap: 10px;">
                        <input type="number" id="ngram-min" value="1" min="1" placeholder="Min">
                        <input type="number" id="ngram-max" value="1" min="1" placeholder="Max">
                    </div>
                </div>
            </div>

            <div>
                <h3>Data Splitting</h3>
                <div class="form-group">
                    <label>Train Ratio (0.0 - 1.0)</label>
                    <input type="number" id="split-ratio" value="0.8" step="0.1" min="0.1" max="0.9">
                    <small>PCA and K-Means will be fit on Train, and applied to Test.</small>
                </div>

                <h3>K-Means Clustering</h3>
                <div class="form-group">
                    <label>Number of Clusters (k)</label>
                    <input type="number" id="kmeans-k" value="3" min="2">
                </div>

                <h3>PCA Reduction</h3>
                <div class="form-group">
                    <label>Number of Components</label>
                    <input type="number" id="pca-components" value="3" readonly title="Fixed to 3 for visualization">
                </div>
            </div>
        </div>

        <button id="run-analysis-btn" style="margin-top: 20px; width: 100%; padding: 15px; font-size: 16px;">Run Analysis</button>
    </div>

    <!-- Step 4: Execution & Results -->
    <div id="step-4" class="step">
        <h2>4. Results</h2>
        <div id="loading-indicator" style="display:none; text-align: center; padding: 20px;">Processing...</div>

        <div id="results-area">

            <div class="results-section">
                <h3>Visualization</h3>
                <p>Circles = Train, Triangles = Test</p>
                <div style="position: relative;">
                    <canvas id="scatter-plot" width="800" height="500"></canvas>
                    <div id="plot-tooltip" class="tooltip"></div>
                </div>
            </div>

            <div class="results-section">
                <h3>TF-IDF Matrix Preview</h3>
                <div class="scrollable-table">
                    <table id="tfidf-preview-table">
                        <thead></thead>
                        <tbody></tbody>
                    </table>
                </div>
            </div>

            <div class="results-section">
                <h3>Processed Data</h3>
                <div class="scrollable-table">
                    <table id="results-table">
                        <thead>
                            <tr>
                                <th>Original Text</th>
                                <th>Cleaned Text</th>
                                <th>Set</th>
                                <th>Cluster ID</th>
                            </tr>
                        </thead>
                        <tbody></tbody>
                    </table>
                </div>
            </div>

            <!-- Step 5: Export -->
            <div class="results-section">
                <h2>5. Export Data</h2>
                <div style="display: flex; gap: 20px;">
                    <button id="download-csv-btn">Download Cleaned Text (CSV)</button>
                    <button id="download-json-btn">Download Vectors (JSON)</button>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
/**
 * Text Cleaning Operations
 */
const Operations = {
    lowercase: (text) => text.toLowerCase(),
    punctuation: (text) => text.replace(/[.,\/#!$%\^&\*;:{}=\-_~()?]/g, ""),
    french_stopwords: (text) => {
        const stopWords = new Set([
            "au", "aux", "avec", "ce", "ces", "dans", "de", "des", "du", "elle", "en", "et", "eux",
            "il", "je", "la", "le", "leur", "lui", "ma", "mais", "me", "meme", "mes", "moi", "mon",
            "ne", "nos", "notre", "nous", "on", "ou", "par", "pas", "pour", "qu", "que", "qui", "sa",
            "se", "ses", "son", "sur", "ta", "te", "tes", "toi", "ton", "tu", "un", "une", "vos", "votre",
            "vous", "c", "d", "j", "l", "à", "m", "n", "s", "t", "y", "été", "étée", "étées", "étés",
            "étant", "suis", "es", "est", "sommes", "êtes", "sont", "serai", "seras", "sera", "serons",
            "serez", "seront", "serais", "serait", "serions", "seriez", "seraient", "étais", "était",
            "étions", "étiez", "étaient", "fus", "fut", "fûmes", "fûtes", "furent", "sois", "soit",
            "soyons", "soyez", "soient", "fusse", "fusses", "fût", "fussions", "fussiez", "fussent",
            "ayant", "eu", "eue", "eues", "eus", "ai", "as", "avons", "avez", "ont", "aurai", "auras",
            "aura", "aurons", "aurez", "auront", "aurais", "aurait", "aurions", "auriez", "auraient",
            "avais", "avait", "avions", "aviez", "avaient", "eut", "eûmes", "eûtes", "eurent", "aie",
            "aies", "ait", "ayons", "ayez", "aient", "eusse", "eusses", "eût", "eussions", "eussiez", "eussent"
        ]);
        return text.split(/\s+/).filter(word => !stopWords.has(word.toLowerCase())).join(" ");
    }
};

function executePipeline(rawData, targetColumn, pipelineItems) {
    const processedList = [];
    const rawList = rawData.map(r => r[targetColumn] || "");

    rawList.forEach((text, idx) => {
        let currentText = text;
        let drop = false;

        for (const item of pipelineItems) {
            const type = item.type;

            if (type === 'regex_remove') {
                const regexStr = item.params.regex;
                if (regexStr) {
                    try {
                        const re = new RegExp(regexStr);
                        if (re.test(currentText)) {
                            drop = true;
                            break;
                        }
                    } catch (e) { console.error("Regex error", e); }
                }
            } else if (type === 'custom') {
                const funcBody = item.params.funcBody;
                try {
                    const func = new Function('text', funcBody);
                    currentText = func(currentText);
                    if (typeof currentText !== 'string') currentText = String(currentText);
                } catch (e) { console.error("Custom Function Error", e); }
            } else if (Operations[type]) {
                currentText = Operations[type](currentText);
            }
        }

        if (!drop) {
            processedList.push({
                original: text,
                cleaned: currentText,
                id: idx
            });
        }
    });

    return processedList;
}

/**
 * IO Operations: CSV Parsing and Downloads
 */

function parseCSV(text, delimiter = ',') {
    const rows = [];
    let currentRow = [];
    let currentField = '';
    let insideQuotes = false;

    // Normalize delimiter to handle potential issues? No, straightforward.
    // However, handling delimiters > 1 char is not required by standard csv but nice.
    // Assuming single char delimiter for now.

    for (let i = 0; i < text.length; i++) {
        const char = text[i];
        const nextChar = text[i + 1];

        if (insideQuotes) {
            if (char === '"') {
                if (nextChar === '"') {
                    currentField += '"';
                    i++;
                } else {
                    insideQuotes = false;
                }
            } else {
                currentField += char;
            }
        } else {
            if (char === '"') {
                insideQuotes = true;
            } else if (char === delimiter) {
                currentRow.push(currentField);
                currentField = '';
            } else if (char === '\n' || char === '\r') {
                if (char === '\r' && nextChar === '\n') {
                    i++;
                }
                currentRow.push(currentField);
                rows.push(currentRow);
                currentRow = [];
                currentField = '';
            } else {
                currentField += char;
            }
        }
    }

    if (currentField || currentRow.length > 0) {
        currentRow.push(currentField);
        rows.push(currentRow);
    }

    if (rows.length < 2) return { headers: [], data: [] };

    const headers = rows[0].map(h => h.trim());
    const data = [];

    for (let i = 1; i < rows.length; i++) {
        const row = rows[i];
        // Allow loose parsing? Or strict?
        // Strict: if (row.length !== headers.length) continue;
        if (row.length !== headers.length) continue;

        const obj = {};
        for (let j = 0; j < headers.length; j++) {
            obj[headers[j]] = row[j];
        }
        data.push(obj);
    }

    return { headers, data };
}

function downloadCSV(data) {
    const headers = ['Original Text', 'Cleaned Text', 'Set', 'Cluster ID'];
    const rows = [headers.join(',')];

    data.forEach(item => {
        // Simple CSV escape
        const row = [
            item.original,
            item.cleaned,
            item.setLabel || '',
            item.cluster
        ].map(t => `"${String(t||"").replace(/"/g, '""')}"`);
        rows.push(row.join(','));
    });

    const blob = new Blob([rows.join('\n')], { type: 'text/csv' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'cleaned_data.csv';
    a.click();
}

function downloadJSON(data, vectors, clusters) {
    const exportData = data.map((item, i) => ({
        id: item.id, // Original Index
        original: item.original,
        cleaned: item.cleaned,
        set: item.setLabel || 'All',
        vector: vectors[i],
        cluster: clusters[i]
    }));

    const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'vectors.json';
    a.click();
}

/**
 * Analysis Algorithms: TF-IDF, PCA, K-Means
 */

function computeTFIDF(cleanedData, options) {
    const { minDf, maxDf, nMin, nMax } = options;
    const docs = cleanedData.map(d => d.cleaned);
    const N = docs.length;

    // 1. Tokenization & N-grams
    const docTokens = docs.map(doc => {
        const tokens = doc.toLowerCase().split(/\s+/).filter(t => t.length > 0);
        const ngrams = [];
        for (let n = nMin; n <= nMax; n++) {
            for (let i = 0; i <= tokens.length - n; i++) {
                ngrams.push(tokens.slice(i, i + n).join(" "));
            }
        }
        return ngrams;
    });

    // 2. Document Frequency
    const df = {};
    docTokens.forEach(tokens => {
        const uniqueTokens = new Set(tokens);
        uniqueTokens.forEach(t => {
            df[t] = (df[t] || 0) + 1;
        });
    });

    // 3. Filtering
    const vocabulary = Object.keys(df).filter(term => {
        const count = df[term];
        const ratio = count / N;
        return count >= minDf && ratio <= maxDf;
    }).sort();

    if (vocabulary.length === 0) throw new Error("Vocabulary is empty after filtering.");

    // 4. Matrix Construction
    const matrix = docTokens.map(tokens => {
        const counts = {};
        tokens.forEach(t => counts[t] = (counts[t] || 0) + 1);

        const row = vocabulary.map(term => {
            const tf = counts[term] || 0;
            const idf = Math.log((N + 1) / (df[term] + 1)) + 1;
            return tf * idf;
        });

        // L2 Normalize
        const sumSq = row.reduce((acc, val) => acc + val * val, 0);
        const norm = Math.sqrt(sumSq);
        return norm > 0 ? row.map(v => v / norm) : row;
    });

    return { matrix, featureNames: vocabulary };
}

function computePCA(X, nComponents, trainIndices) {
    const nSamples = X.length;
    const nFeatures = X[0].length;

    // Use only training data to compute statistics
    const trainX = trainIndices ? trainIndices.map(i => X[i]) : X;
    const nTrain = trainX.length;

    // 1. Standardize (Center and Scale) based on Train
    const means = new Array(nFeatures).fill(0);
    const stds = new Array(nFeatures).fill(0);

    for (let j = 0; j < nFeatures; j++) {
        let sum = 0;
        for (let i = 0; i < nTrain; i++) sum += trainX[i][j];
        means[j] = sum / nTrain;
    }

    for (let j = 0; j < nFeatures; j++) {
        let sumSq = 0;
        for (let i = 0; i < nTrain; i++) {
            sumSq += Math.pow(trainX[i][j] - means[j], 2);
        }
        stds[j] = Math.sqrt(sumSq / (nTrain - 1)) || 1;
    }

    // Standardize ALL data (Train + Test)
    const Z = [];
    for (let i = 0; i < nSamples; i++) {
        const row = [];
        for (let j = 0; j < nFeatures; j++) {
            row.push((X[i][j] - means[j]) / stds[j]);
        }
        Z.push(row);
    }

    // 2. Covariance Matrix on Train Z
    // We need to standardize TrainX specifically for Covariance calc
    const trainZ = trainIndices ? trainIndices.map(i => Z[i]) : Z;

    const C = new Array(nFeatures);
    for (let i = 0; i < nFeatures; i++) C[i] = new Array(nFeatures).fill(0);

    for (let i = 0; i < nFeatures; i++) {
        for (let j = i; j < nFeatures; j++) {
            let sum = 0;
            for (let k = 0; k < nTrain; k++) {
                sum += trainZ[k][i] * trainZ[k][j];
            }
            const cov = sum / (nTrain - 1);
            C[i][j] = cov;
            C[j][i] = cov;
        }
    }

    // 3. Eigen Decomposition
    const { eigenvectors, eigenvalues } = jacobi(C);

    // 4. Sort and Project
    const indices = eigenvalues.map((e, i) => i);
    indices.sort((a, b) => eigenvalues[b] - eigenvalues[a]);

    const topIndices = indices.slice(0, nComponents);
    const projectionMatrix = topIndices.map(idx => eigenvectors[idx]);

    // Project ALL data
    const pcaVectors = [];
    for (let i = 0; i < nSamples; i++) {
        const row = [];
        for (let k = 0; k < nComponents; k++) {
            let sum = 0;
            for (let j = 0; j < nFeatures; j++) {
                sum += Z[i][j] * projectionMatrix[k][j];
            }
            row.push(sum);
        }
        pcaVectors.push(row);
    }

    return pcaVectors;
}

function jacobi(A, maxIter = 100, tol = 1e-8) {
    const n = A.length;
    let M = A.map(row => [...row]);
    let V = Array.from({ length: n }, (_, i) =>
        Array.from({ length: n }, (_, j) => (i === j ? 1 : 0))
    );

    for (let iter = 0; iter < maxIter; iter++) {
        let maxVal = 0;
        let p = 0, q = 0;
        for (let i = 0; i < n - 1; i++) {
            for (let j = i + 1; j < n; j++) {
                if (Math.abs(M[i][j]) > maxVal) {
                    maxVal = Math.abs(M[i][j]);
                    p = i;
                    q = j;
                }
            }
        }

        if (maxVal < tol) break;

        const app = M[p][p];
        const aqq = M[q][q];
        const apq = M[p][q];

        const phi = 0.5 * Math.atan2(2 * apq, aqq - app);
        const c = Math.cos(phi);
        const s = Math.sin(phi);

        M[p][p] = c * c * app - 2 * s * c * apq + s * s * aqq;
        M[q][q] = s * s * app + 2 * s * c * apq + c * c * aqq;
        M[p][q] = 0;
        M[q][p] = 0;

        for (let i = 0; i < n; i++) {
            if (i !== p && i !== q) {
                const api = M[i][p];
                const aqi = M[i][q];
                M[i][p] = c * api - s * aqi;
                M[p][i] = M[i][p];
                M[i][q] = s * api + c * aqi;
                M[q][i] = M[i][q];
            }
        }

        for (let i = 0; i < n; i++) {
            const vip = V[i][p];
            const viq = V[i][q];
            V[i][p] = c * vip - s * viq;
            V[i][q] = s * vip + c * viq;
        }
    }

    const eigenvalues = [];
    for (let i = 0; i < n; i++) eigenvalues.push(M[i][i]);

    const eigenvectors = [];
    for (let j = 0; j < n; j++) {
        const vec = [];
        for (let i = 0; i < n; i++) vec.push(V[i][j]);
        eigenvectors.push(vec);
    }

    return { eigenvalues, eigenvectors };
}

function computeKMeans(data, k, trainIndices) {
    const n = data.length;

    // Use ONLY Train data for initialization and updates
    const trainData = trainIndices ? trainIndices.map(i => data[i]) : data;
    const nTrain = trainData.length;

    // Initialize Centroids Randomly from Train Data
    let centroids = [];
    const usedIndices = new Set();
    while (centroids.length < k && usedIndices.size < nTrain) {
        const idx = Math.floor(Math.random() * nTrain);
        if (!usedIndices.has(idx)) {
            usedIndices.add(idx);
            centroids.push([...trainData[idx]]);
        }
    }
    while (centroids.length < k) centroids.push([...trainData[0]]);

    const dim = data[0].length;
    let assignments = new Array(n).fill(-1);
    let changed = true;
    let maxIter = 100;

    for (let iter = 0; iter < maxIter && changed; iter++) {
        changed = false;

        // Assignment Step: Assign ALL data to centroids
        for (let i = 0; i < n; i++) {
            let minDist = Infinity;
            let cluster = -1;
            for (let j = 0; j < k; j++) {
                const d = euclidean(data[i], centroids[j]);
                if (d < minDist) {
                    minDist = d;
                    cluster = j;
                }
            }
            if (assignments[i] !== cluster) {
                assignments[i] = cluster;
                changed = true;
            }
        }

        // Update Step: Update centroids using ONLY Train data
        const newCentroids = Array.from({ length: k }, () => new Array(dim).fill(0));
        const counts = new Array(k).fill(0);

        // Iterate over TRAIN data only
        if (trainIndices) {
            trainIndices.forEach(realIdx => {
                const c = assignments[realIdx];
                for (let d = 0; d < dim; d++) {
                    newCentroids[c][d] += data[realIdx][d];
                }
                counts[c]++;
            });
        } else {
             for (let i = 0; i < n; i++) {
                const c = assignments[i];
                for (let d = 0; d < dim; d++) {
                    newCentroids[c][d] += data[i][d];
                }
                counts[c]++;
            }
        }

        for (let j = 0; j < k; j++) {
            if (counts[j] > 0) {
                for (let d = 0; d < dim; d++) {
                    centroids[j][d] = newCentroids[j][d] / counts[j];
                }
            }
        }
    }

    return assignments;
}

function euclidean(a, b) {
    let sum = 0;
    for (let i = 0; i < a.length; i++) {
        sum += (a[i] - b[i]) ** 2;
    }
    return Math.sqrt(sum);
}

/**
 * Visualization: Tables and Scatter Plot
 */

function renderResults(state) {
    // 1. Table
    const tbody = document.querySelector('#results-table tbody');
    tbody.innerHTML = '';

    // Render first 500 rows to avoid freezing DOM if large
    const limit = 500;

    state.cleanedData.slice(0, limit).forEach((item, i) => {
        const row = document.createElement('tr');
        const cId = state.clusters[i];
        const setLabel = state.cleanedData[i].setLabel || "-";

        row.innerHTML = `
            <td><div style="max-height:100px; overflow-y:auto;">${escapeHtml(item.original)}</div></td>
            <td><div style="max-height:100px; overflow-y:auto;">${escapeHtml(item.cleaned)}</div></td>
            <td>${setLabel}</td>
            <td>${cId}</td>
        `;
        tbody.appendChild(row);
    });

    if (state.cleanedData.length > limit) {
        const row = document.createElement('tr');
        row.innerHTML = `<td colspan="4" style="text-align:center; color:#999;">... ${state.cleanedData.length - limit} more rows hidden ...</td>`;
        tbody.appendChild(row);
    }

    // 2. TF-IDF Preview
    const matrixBody = document.querySelector('#tfidf-preview-table tbody');
    const matrixHead = document.querySelector('#tfidf-preview-table thead');
    matrixBody.innerHTML = '';
    matrixHead.innerHTML = '';

    // Headers
    const headRow = document.createElement('tr');
    headRow.innerHTML = '<th>Doc ID</th>' + state.featureNames.slice(0, 20).map(f => `<th>${f}</th>`).join('');
    matrixHead.appendChild(headRow);

    // Rows (first 10)
    state.tfidfMatrix.slice(0, 10).forEach((vec, i) => {
        const tr = document.createElement('tr');
        tr.innerHTML = `<td>${i}</td>` + vec.slice(0, 20).map(v => `<td>${v.toFixed(3)}</td>`).join('');
        matrixBody.appendChild(tr);
    });

    // 3. Scatter Plot
    drawScatterPlot(state);
}

function drawScatterPlot(state) {
    const canvas = document.getElementById('scatter-plot');
    const ctx = canvas.getContext('2d');
    const width = canvas.width;
    const height = canvas.height;

    ctx.clearRect(0, 0, width, height);

    if (!state.pcaVectors || state.pcaVectors.length === 0) return;

    // 3D Visualization Logic
    const points = state.pcaVectors;

    // Camera / Rotation
    const rotX = state.rotationX;
    const rotY = state.rotationY;
    const scale = state.scale || 1;
    const dist = state.visDistance || 2;

    const cx = width / 2;
    const cy = height / 2;

    // Scale data to fit loosely in -1 to 1 range for rendering
    // We compute global bounds once preferably, but here we can just do it every time
    // since dataset size is small.
    // Actually, PCA results are already standardized (roughly N(0,1))
    // So we can assume they are roughly in range [-3, 3].
    // Let's normalize explicitly to be safe.

    // Find Max Abs value to normalize
    let maxVal = 0;
    for(let i=0; i<points.length; i++) {
        for(let j=0; j<points[i].length; j++) {
             maxVal = Math.max(maxVal, Math.abs(points[i][j]));
        }
    }
    const dataScale = 150 * scale; // Base scale in pixels

    const projectedPoints = [];

    // Colors
    const colors = ['#e74c3c', '#3498db', '#2ecc71', '#9b59b6', '#f1c40f', '#e67e22', '#1abc9c', '#34495e'];

    points.forEach((vec, i) => {
        const x = vec[0] / maxVal;
        const y = vec[1] / maxVal;
        const z = vec[2] / maxVal; // 3rd component

        // Rotation around Y
        const cosY = Math.cos(rotY);
        const sinY = Math.sin(rotY);
        const x1 = x * cosY - z * sinY;
        const z1 = z * cosY + x * sinY;

        // Rotation around X
        const cosX = Math.cos(rotX);
        const sinX = Math.sin(rotX);
        const y2 = y * cosX - z1 * sinX;
        const z2 = z1 * cosX + y * sinX;

        // Projection (Perspective)
        // Camera is at (0, 0, dist)
        // z2 is in [-1, 1] roughly.
        // We shift z2 so it's relative to camera
        const zDepth = dist - z2;

        // Perspective factor
        const f = 400 / (zDepth < 0.1 ? 0.1 : zDepth);

        const px = x1 * f * scale + cx;
        const py = -y2 * f * scale + cy; // Invert Y for canvas

        projectedPoints.push({
            x: px,
            y: py,
            z: zDepth, // Store depth for sorting
            index: i,
            r: 5 + (2 / zDepth) * scale // Size varies by depth
        });
    });

    // Painter's Algorithm: Sort by depth (far to near)
    projectedPoints.sort((a, b) => b.z - a.z);

    state.plotPoints = projectedPoints;

    // Draw Points
    projectedPoints.forEach(p => {
        const cluster = state.clusters[p.index];
        const isTest = state.cleanedData[p.index].setLabel === 'Test';

        ctx.fillStyle = colors[cluster % colors.length];

        // Fade out distant points?
        // ctx.globalAlpha = Math.max(0.1, 1 - (p.z / 5));

        ctx.beginPath();
        if (isTest) {
            // Triangle
            const r = p.r * 1.2;
            ctx.moveTo(p.x, p.y - r);
            ctx.lineTo(p.x + r, p.y + r);
            ctx.lineTo(p.x - r, p.y + r);
            ctx.closePath();
        } else {
            // Circle
            ctx.arc(p.x, p.y, p.r, 0, 2 * Math.PI);
        }
        ctx.fill();
        ctx.strokeStyle = 'rgba(255,255,255,0.8)';
        ctx.lineWidth = 1;
        ctx.stroke();

        // ctx.globalAlpha = 1.0;
    });

    // Optional: Draw Axes (3D)
    // Not strictly necessary but helpful.
    // We can just draw a small triad in the corner or center.
}

function escapeHtml(text) {
    if (!text) return "";
    return text.replace(/&/g, "&amp;")
               .replace(/</g, "&lt;")
               .replace(/>/g, "&gt;")
               .replace(/"/g, "&quot;")
               .replace(/'/g, "&#039;");
}

/**
 * APP STATE
 */
const state = {
    rawData: [],
    headers: [],
    targetColumn: null,
    cleanedData: [],
    tfidfMatrix: null,
    featureNames: [],
    pcaVectors: null,
    clusters: null,
    trainIndices: null,
    step: 1,
    // Visualization State
    rotationX: 0,
    rotationY: 0,
    scale: 1,
    visDistance: 2,
    isDragging: false,
    lastMouseX: 0,
    lastMouseY: 0
};

function init() {
    // Step 1: File Input
    document.getElementById('csv-file').addEventListener('change', handleFileUpload);
    document.getElementById('confirm-column-btn').addEventListener('click', () => {
        state.targetColumn = document.getElementById('target-column').value;
        activateStep(2);
    });

    // Step 2: Pipeline
    document.getElementById('add-op-btn').addEventListener('click', addPipelineOperation);
    document.getElementById('confirm-pipeline-btn').addEventListener('click', () => activateStep(3));
    document.getElementById('preview-cleaning-btn').addEventListener('click', showCleaningPreview);

    // Step 3: Analysis
    document.getElementById('run-analysis-btn').addEventListener('click', runAnalysis);

    // Step 4: Export
    document.getElementById('download-csv-btn').addEventListener('click', () => downloadCSV(state.cleanedData));
    document.getElementById('download-json-btn').addEventListener('click', () => downloadJSON(state.cleanedData, state.pcaVectors, state.clusters));

    // Global Tooltip Listener
    const canvas = document.getElementById('scatter-plot');

    // Interaction Listeners
    canvas.addEventListener('mousedown', handleMouseDown);
    canvas.addEventListener('mousemove', handleMouseMove);
    canvas.addEventListener('mouseup', handleMouseUp);
    canvas.addEventListener('mouseleave', handleMouseUp);
    canvas.addEventListener('wheel', handleWheel);
}

function activateStep(stepNum) {
    state.step = stepNum;
    for (let i = 1; i <= 4; i++) {
        const el = document.getElementById(`step-${i}`);
        if (i <= stepNum) {
            el.classList.add('active');
        } else {
            el.classList.remove('active');
        }
    }
    document.getElementById(`step-${stepNum}`).scrollIntoView({ behavior: 'smooth' });
}

function handleFileUpload(e) {
    const file = e.target.files[0];
    if (!file) return;

    const delimiter = document.getElementById('csv-delimiter').value || ',';
    const encoding = document.getElementById('csv-encoding').value || 'UTF-8';

    const reader = new FileReader();
    reader.onload = function(evt) {
        try {
            const text = evt.target.result;
            const result = parseCSV(text, delimiter);
            state.rawData = result.data;
            state.headers = result.headers;

            const select = document.getElementById('target-column');
            select.innerHTML = '';
            state.headers.forEach(h => {
                const option = document.createElement('option');
                option.value = h;
                option.textContent = h;
                select.appendChild(option);
            });
            document.getElementById('column-select-group').style.display = 'block';
        } catch (err) {
            console.error("Error processing file:", err);
            alert("Error parsing CSV. Check format/delimiter.");
        }
    };
    reader.readAsText(file, encoding);
}

function getPipeline() {
    const items = document.querySelectorAll('.pipeline-item');
    const pipeline = [];
    items.forEach(item => {
        const type = item.dataset.type;
        const params = {};
        if (type === 'regex_remove') {
            params.regex = item.querySelector('.op-input-regex').value;
        } else if (type === 'custom') {
            params.funcBody = item.querySelector('.op-input-custom').value;
        }
        pipeline.push({ type, params });
    });
    return pipeline;
}

function addPipelineOperation() {
    const type = document.getElementById('operation-select').value;
    const container = document.getElementById('pipeline-container');
    const emptyMsg = document.getElementById('pipeline-empty-msg');

    if (emptyMsg) emptyMsg.style.display = 'none';

    const opId = Date.now();
    const item = document.createElement('div');
    item.className = 'pipeline-item';
    item.dataset.id = opId;
    item.dataset.type = type;

    let detailsHtml = `<strong>${type}</strong>`;
    if (type === 'regex_remove') {
        detailsHtml += ` <input type="text" placeholder="Enter Regex (e.g. ^Ref:)" class="op-input-regex">`;
    } else if (type === 'custom') {
        detailsHtml += ` <textarea placeholder="return text.replace(/a/g, 'b');" class="op-input-custom"></textarea>`;
    }

    item.innerHTML = `
        <div class="details">${detailsHtml}</div>
        <div class="controls">
            <button class="remove-btn" data-id="${opId}">X</button>
            <div style="display:flex; flex-direction:column; margin-left:5px;">
                <button class="move-up-btn" data-id="${opId}" style="padding:2px; font-size:10px;">▲</button>
                <button class="move-down-btn" data-id="${opId}" style="padding:2px; font-size:10px;">▼</button>
            </div>
        </div>
    `;

    // Attach listeners dynamically or use delegation. Using simple closures for now.
    item.querySelector('.remove-btn').addEventListener('click', () => item.remove());
    item.querySelector('.move-up-btn').addEventListener('click', () => {
        if (item.previousElementSibling && item.previousElementSibling.id !== 'pipeline-empty-msg') {
            container.insertBefore(item, item.previousElementSibling);
        }
    });
    item.querySelector('.move-down-btn').addEventListener('click', () => {
        if (item.nextElementSibling) {
            container.insertBefore(item.nextElementSibling, item);
        }
    });

    container.appendChild(item);
}

function showCleaningPreview() {
    const pipeline = getPipeline();
    if (!state.rawData.length) return;

    // Preview first 5 rows
    const subset = state.rawData.slice(0, 5);
    const cleaned = executePipeline(subset, state.targetColumn, pipeline);

    const container = document.getElementById('cleaning-preview-container');
    container.innerHTML = '<h4>Preview (First 5 Rows)</h4>';
    const table = document.createElement('table');
    table.innerHTML = `<thead><tr><th>Original</th><th>Cleaned</th></tr></thead><tbody></tbody>`;
    const tbody = table.querySelector('tbody');

    cleaned.forEach(item => {
        const tr = document.createElement('tr');
        tr.innerHTML = `<td>${item.original}</td><td>${item.cleaned}</td>`;
        tbody.appendChild(tr);
    });

    container.appendChild(table);
    container.style.display = 'block';
}

async function runAnalysis() {
    document.getElementById('loading-indicator').style.display = 'block';
    document.getElementById('results-area').style.display = 'none';

    setTimeout(() => {
        try {
            // 1. Full Pipeline
            const pipeline = getPipeline();
            state.cleanedData = executePipeline(state.rawData, state.targetColumn, pipeline);

            if (state.cleanedData.length === 0) {
                throw new Error("No data remaining after cleaning.");
            }

            // 2. Data Splitting
            const splitRatio = parseFloat(document.getElementById('split-ratio').value) || 0.8;
            performSplit(splitRatio);

            // 3. Analysis
            const tfidfOptions = {
                minDf: parseInt(document.getElementById('min-df').value),
                maxDf: parseFloat(document.getElementById('max-df').value),
                nMin: parseInt(document.getElementById('ngram-min').value),
                nMax: parseInt(document.getElementById('ngram-max').value)
            };
            const result = computeTFIDF(state.cleanedData, tfidfOptions);
            state.tfidfMatrix = result.matrix;
            state.featureNames = result.featureNames;

            state.pcaVectors = computePCA(state.tfidfMatrix, 3, state.trainIndices);

            const k = parseInt(document.getElementById('kmeans-k').value);
            state.clusters = computeKMeans(state.pcaVectors, k, state.trainIndices);

            // 4. Render
            renderResults(state);
            activateStep(4);
        } catch (err) {
            alert("Error: " + err.message);
            console.error(err);
        } finally {
            document.getElementById('loading-indicator').style.display = 'none';
            document.getElementById('results-area').style.display = 'block';
        }
    }, 100);
}

function performSplit(ratio) {
    const n = state.cleanedData.length;
    const indices = Array.from({ length: n }, (_, i) => i);

    // Shuffle
    for (let i = n - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [indices[i], indices[j]] = [indices[j], indices[i]];
    }

    const nTrain = Math.floor(n * ratio);
    const trainIndices = indices.slice(0, nTrain);
    const testIndices = indices.slice(nTrain);

    const trainSet = new Set(trainIndices);
    state.cleanedData.forEach((item, i) => {
        item.setLabel = trainSet.has(i) ? 'Train' : 'Test';
    });

    state.trainIndices = trainIndices;
}

function handleMouseDown(e) {
    if (!state.pcaVectors) return;
    state.isDragging = true;
    state.lastMouseX = e.clientX;
    state.lastMouseY = e.clientY;
}

function handleMouseMove(e) {
    if (!state.pcaVectors) return;

    const canvas = document.getElementById('scatter-plot');
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;

    if (state.isDragging) {
        const deltaX = e.clientX - state.lastMouseX;
        const deltaY = e.clientY - state.lastMouseY;

        state.rotationY += deltaX * 0.01;
        state.rotationX += deltaY * 0.01;

        state.lastMouseX = e.clientX;
        state.lastMouseY = e.clientY;

        drawScatterPlot(state);
    } else {
        // Tooltip logic
        handleTooltip(mx, my);
    }
}

function handleMouseUp(e) {
    state.isDragging = false;
}

function handleWheel(e) {
    if (!state.pcaVectors) return;
    e.preventDefault();

    const zoomSpeed = 0.1;
    if (e.deltaY < 0) {
        state.scale *= (1 + zoomSpeed);
    } else {
        state.scale /= (1 + zoomSpeed);
    }
    drawScatterPlot(state);
}

function handleTooltip(mx, my) {
    if (!state.plotPoints) return;

    // Use hit detection on projected points
    // Sort by Z (implicit in painters algo, but we just check distance in 2D)
    // Actually for 3D picking we should probably check Z-buffer or just pick closest 2D point
    // but prioritize ones "on top".
    // Since we draw back-to-front, the last drawn points are on top.
    // So we should search in reverse order or just find all hits and pick max Z?
    // state.plotPoints should store Z or index.

    // Simple closest distance check
    let bestHit = null;
    let minDist = Infinity;

    for (let i = state.plotPoints.length - 1; i >= 0; i--) {
        const p = state.plotPoints[i];
        const dist = Math.sqrt((p.x - mx)**2 + (p.y - my)**2);
        if (dist < p.r + 2) {
             // Found a hit. Since we iterate back-to-front (top-to-bottom),
             // the first one we find is the topmost one.
             bestHit = p;
             break;
        }
    }

    const tooltip = document.getElementById('plot-tooltip');
    if (bestHit) {
        tooltip.style.display = 'block';
        tooltip.style.left = (mx + 10) + 'px';
        tooltip.style.top = (my + 10) + 'px';
        const item = state.cleanedData[bestHit.index];

        // Use CLEANED text
        let content = item.cleaned.substring(0, 200);
        if (item.cleaned.length > 200) content += "...";

        tooltip.innerHTML = `
            <strong>${item.setLabel}</strong> (Cluster ${state.clusters[bestHit.index]})<br>
            <div style="max-width:250px; word-wrap:break-word;">${content}</div>
        `;
    } else {
        tooltip.style.display = 'none';
    }
}

// Start
init();
</script>
</body>
</html>